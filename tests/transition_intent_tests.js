
var TransitionIntent = Router.TransitionIntent;
var TransitionState  = Router.TransitionState;

module("TransitionIntent", {

});

test("it exists", function() {
  ok(new TransitionIntent());
});

test("it can be applied to an empty state", function() {

  var state = new TransitionState();

  var intent = new TransitionIntent();

  var newState = intent.applyToState();

  ok(true, "made it through");

  // assert that newState has N handlerStates, all
  // unresolved.

});

test("it can be applied to a non-empty state", function() {

  var state = new TransitionState();

  var intent = new TransitionIntent();

  var newState = intent.applyToState();

  ok(true, "made it through");

  // assert that newState has N handlerStates, all
  // unresolved.
});

test("applying to a state is idempotent", function() {

  var state = new TransitionState();

  var intent = new TransitionIntent();

  var newState = intent.applyToState(state);

  var newNewState = intent.applyToState(newState);

  ok(true, "made it through");

  // assert newState and newNewState contain same
  // shit (though different references)
});


/* A TransitionState has an array of handlerInfos,
 * generated by applying a TransitionIntent to 
 * a TransitionState.
 *
 * so, from blank to '/foo/bar':
 *
 * [
 *   {
 *     name: 'foo',
 *     params: {}
 *   },
 *   {
 *     name: 'bar',
 *     params: {}
 *   }
 * ]
 *
 *
 */



// What's the interface?
// You basically need it to generate handlerInfos, right?
// What do you need to know in order to transition?
// Specifically, what are the ugly bitchass parts of code?
//
// So, you need to figure out a match point.
//
// What about serialize? What are the assumptions of what
// can be passed to serialize? Basically, the thing
// must already be resolved, but you can't know that...
// So, we can't check this until we have all params.
//
// We could support something like transitionTo('foo', promiseObj, 'stringparams')
// where even if the last stringparams caused a slow promise in model,
// we could update it right away because at that point, we have
// all the bitches. A fascinating notion.
//
// And as for matchpoint shit, well, there are 2 match points
// - pre-transition matchpoint
//   - compare current TransitionState with (TransitionState+TransitionIntent)
// - post-model-resolve matchpoint
//   - just compare `TransitionState`s
//
// The first governs whether model hooks run. The latter governs whether
// enter/exit/update are called.
//
// Pre-transition matchpoint:
// - a route matches param is provided and matches exactly
// - model is provided and matches exactly
//
//

//test("", function() {
  //ok(new TransitionIntent());
//});
//
//
// First thing I wanna test: empty TransitionState + TransitionIntent
// This should produce:... matchPoint of -1
// A Transition with empty state
//
// Use case: a Router starts off with an empty state.
// Then you transition into somewhere, ideally with URL,
// but we support named as well.
//
// So for that to fit into our algorithm, we need to
//
// 1) Look at current state
// 2) Determine match point
// 3) destinationState = currentState + intent // what does this return?
//    - URLIntent: assume same models if params match
//    - NamedIntent: assume same params if models match
//
//    Basically, applying an intent should just lop off the
//    arrays where param or model doesn't match.
//
//    originState = ['foo', 'bar', 'baz']
//    intent = ['foo', 'bar', 'shit']
//    output => ['foo', 'bar']
//
//    REHASH:
//
//    originState = [ResolvedHandlerInfo, ResolvedHandlerInfo, //    ResolvedHandlerInfo]
//    intent = URLIntent('/foo/bar/shit')
//    output => [ResolvedHandlerInfo, ResolvedHandlerInfo, {
//      resolve: function() {
//        if (this.params) {
//          // Try and resolve a model
//        } else {
//        }
//      }
//    })
//
//
// handlerInfos = [HandlerInfo, HandlerInfo, HandlerInfo]
//
// HandlerInfo = {
//   isResolved: true/false,
//   params: {},
//   context: object
// }
//
// handlerInfo.resolve()
// - This just returns RSVP.resolve() if already resolved
// - else
//
// - currentHandlerInfos
//
// HandlerInfo
//   - if isResolved, then params and context are present
//   - else
//     - params is present OR context is present, never neither.
//
// 4) getMatchPoint(currentState, destinationState)
// 5)
